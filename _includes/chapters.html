<!-- julia in a nutshell -->
<div class="container pt-sm-2">
  <div class="row">
    <div class="col-lg-4 col-md-3 chapters "><hr/></div>
    <div class="col-lg-4 col-md-6 chapters section-heading">
      <h2 class="lead secondary-heading">
        Chapter Outlines
      </h2>
    </div>
    <div class="col-lg-4 col-md-3 chapters"><hr/></div>
  </div>

  <br />

  <div class="row">
    <div class="col-lg-6 col-md-6 chapter">
      <h4>1: Julia is Fast</h4>
      <p>
        Julia is a high- performance language, with the possibility to run programs that are
        competitive in performance with code written in C. This chapter explains why Julia code is fast.
        It also provides context and sets the stage for the rest of the book
      </p>
    </div>
    <div class="col-lg-6 col-md-6 chapter">
      <h4>2: Analyzing Performance</h4>
      <p>
        Shows you how to measure the speed of Julia programs and understand where the bottlenecks are.
        It also shows you how to measure the memory usage of Julia programs and the
        amount of time spent on garbage collection
      </p>
    </div>
    <div class="col-lg-6 col-md-6 chapter">
      <h4>3: Types, Type Inference, and Stability</h4>
      <p>
        One of the principal ways in which Julia achieves its performance goals is by using type information.
        This chapter describes how the Julia compiler uses type information to create fast machine code.
        It describes ways of writing Julia code to provide effective type information to the Julia compiler.
      </p>
    </div>

    <div class="col-lg-6 col-md-6 chapter">
      <h4>4: Making Fast Function Calls</h4>
      <p>
        Functions are the primary artifacts for code organization in Julia, with multiple dispatch
        being the single most important design feature in the language. This chapter shows you how to
        use these facilities for fast code.
      </p>
    </div>
    <div class="col-lg-6 col-md-6 chapter">
      <h4>5: Fast Numbers</h4>
      <p>
        Describes some internals of Julia's number types in relation to performance,
        and helps you understand the design decisions that were made to achieve that performance.
      </p>
    </div>
    <div class="col-lg-6 col-md-6 chapter">
      <h4>6: Using Arrays</h4>
      <p>
        Arrays are one of the most important data structures in scientific programming.
        This chapter shows you how to get the best performance out of your arraysâ€”how to store them,
        and how to operate on them
      </p>
    </div>
    <div class="col-lg-6 col-md-6 chapter">
      <h4>7: Accelerating Code with the GPU</h4>
      <p>
        In recent years, the general- purpose GPU has turned out to be one of the best ways of
        running fast parallel computations. Julia provides a unique method for compiling high-level
        code to the GPU. This chapter shows you how to use the GPU with Julia.
      </p>
    </div>
    <div class="col-lg-6 col-md-6 chapter">
      <h4>8: Concurrent Programming with Tasks</h4>
      <p>
        Most programs in Julia run on a single thread, on a single processor core.
        However, certain concurrent primitives make it possible to run parallel, or
        seemingly parallel, operations, without the full complexities of shared memory
        multi-threading.
        In this chapter, we discuss how the concepts of tasks and asynchronous IO help create responsive programs.
      </p>
    </div>
    <div class="col-lg-6 col-md-6 chapter">
      <h4>9: Threads</h4>
      <p>
        In this chapter, we discuss the details of Julia's experimantal support for shared memory multi-threading,
        and see how this is different from other languages. We see how to speed up our
        computations using threads, and learn some of the limitations that currently exist in this model.
      </p>
    </div>
    <div class="col-lg-6 col-md-6 chapter">
      <h4>10, Distributed Computing with Julia</h4>
      <p>
        Recognizes that there comes a time in every large computation's life when living on a single machine is not enough. There is either too much data to fit in the memory of a single machine, or computations need to be finished quicker than can be achieved on all the cores of a single processor. At that stage, computation moves from a single machine to many. Julia comes with advanced distributed computation facilities built in, which we describe in this chapter.
      </p>
    </div>
  </div>

</div>
<!-- end julia in a nutshell -->
